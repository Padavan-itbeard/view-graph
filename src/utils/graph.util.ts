import * as dagre from 'dagre';
import { GraphData, GraphEdge, GraphNode, NodeStyle } from '../@types/graph.type';

// TODO: calculate based on font size
const LETTER_WIDTH = 12 as const;
const LETTER_HEIGHT = 19 as const;

export const GRAPH_NODE_DEFAULT_ID = 'graphNode' as const;

export function computeGraph(data: GraphData, nodeStyle: Map<string, NodeStyle>): { nodes: GraphNode[]; edges: GraphEdge[] } | undefined {
  if (data == null) {
    return;
  }

  let longestLabel = 0;

  for (const node of data.nodes) {
    const nodeLabelLength = getTextWidth(node.label);
    if (nodeLabelLength > longestLabel) {
      longestLabel = nodeLabelLength;
    }
  }

  // Create a new directed graph
  let g = new dagre.graphlib.Graph({ directed: true, multigraph: true });

  g.setGraph({
    // TODO: property
    ranker: 'tight-tree',
    rankdir: 'LR',
    ranksep: longestLabel + 50,
  } as any);

  // Default to assigning a new object as a label for each new edge.
  g.setDefaultEdgeLabel(function () {
    return {};
  });

  data.nodes.forEach((value) => {
    const nodeSize = nodeStyle.get(String(value.styleId)) ?? nodeStyle.get(GRAPH_NODE_DEFAULT_ID)!;

    // Add nodes to the graph. The first argument is the node id. The second is
    // metadata for a node. In this case we're going to add labels to each of
    // our nodes.
    g.setNode(value.id, {
      label: value.label,
      width: nodeSize.width,
      height: nodeSize.height,
    });
  });

  // Add edges to the graph
  data.edges.forEach((value) => {
    if (value.from !== value.to) {
      g.setEdge(String(value.from), String(value.to), {
        label: value.label,
        key: `${value.from}->${value.to}`.replace(/\s/g, '_'),
        width: getTextWidth(value.label ?? ''),
        height: LETTER_HEIGHT,
        labelpos: 'c',
      });
    }
  });

  dagre.layout(g);

  // develop the graph's nodes based on known data (data.nodes) instead on autogenerated (g.nodes())
  const nodes = data.nodes.map((dataNode) => {
    const node = g.node(dataNode.id);

    return {
      key: dataNode.id,
      style: dataNode.styleId,
      label: node.label,
      cx: node.x,
      cy: node.y,
      width: node.width,
      height: node.height,
    };
  });

  const edges = g.edges().map((value) => {
    const edge = g.edge(value);
    let label: GraphEdge['label'] = undefined;

    if (edge.y != null && edge.y != null) {
      label = {
        text: edge.label,
        x: edge.x,
        y: edge.y - 10,
      };
    }

    return {
      key: edge.key,
      points: edge.points,
      label,
    };
  });

  return {
    nodes,
    edges,
  };
}

function getTextWidth(text: string) {
  return LETTER_WIDTH * text.length;
}

export function getNodeStyleMap(nodeStyle: NodeStyle | NodeStyle[]) {
  nodeStyle = Array.isArray(nodeStyle) ? nodeStyle : [nodeStyle];

  const nsMap = new Map<string, NodeStyle>(nodeStyle.map((it) => [it.id ?? GRAPH_NODE_DEFAULT_ID, it]));

  if (!nsMap.has(GRAPH_NODE_DEFAULT_ID)) {
    nsMap.set(GRAPH_NODE_DEFAULT_ID, nodeStyle[0]);
  }

  return nsMap;
}
