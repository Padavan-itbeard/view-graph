import * as dagre from 'dagre';
import { GraphData, GraphEdge, GraphNode } from '../typings/graph.type';

export function computeGraph(
  data: GraphData,
  nodeSize: { width: number; height: number }
): { nodes: GraphNode[]; edges: GraphEdge[] } | undefined {
  if (data == null) {
    return;
  }

  // Create a new directed graph
  let g = new dagre.graphlib.Graph({ directed: true, multigraph: true });

  g.setGraph({
    // TODO: property
    ranker: 'tight-tree',
    rankdir: 'LR',
    ranksep: 50,
  } as any);

  // Default to assigning a new object as a label for each new edge.
  g.setDefaultEdgeLabel(function () {
    return {};
  });

  data.nodes.forEach((value) => {
    // Add nodes to the graph. The first argument is the node id. The second is
    // metadata for a node. In this case we're going to add labels to each of
    // our nodes.
    g.setNode(value.id, { label: value.label, width: nodeSize.width, height: nodeSize.height });
  });

  // Add edges to the graph
  data.edges.forEach((value) => {
    if (value.from !== value.to) {
      g.setEdge(String(value.from), String(value.to), {
        label: value.label,
        name: value.from + '->' + value.to,
        width: 12 * (value.label ?? '').length, // TODO: calculate based on something
        height: 19, // TODO: calculate based on something
        labelpos: 'c',
      });
    }
  });

  dagre.layout(g);

  // develop the graph's nodes based on known data (data.nodes) instead on autogenerated (g.nodes())
  const nodes = data.nodes.map((dataNote) => {
    const node = g.node(dataNote.id);

    return {
      key: dataNote.id,
      label: node.label,
      cx: node.x,
      cy: node.y,
      width: node.width,
      height: node.height,
    };
  });

  const edges = g.edges().map((value) => {
    const edge = g.edge(value);
    let label: GraphEdge['label'] = undefined;

    if (edge.y != null && edge.y != null) {
      label = {
        text: edge.label,
        x: edge.x,
        y: edge.y - 10,
      };
    }

    return {
      key: value.v + '->' + value.w,
      points: edge.points,
      label,
    };
  });

  return {
    nodes,
    edges,
  };
}
